<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ëª¨ë°”ì¼ëƒ¥ì½”ëŒ€ì „!</title>
  <style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: #111;
    font-family: system-ui, sans-serif;
    color: #fff;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    overflow: hidden;
  }
  #gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
  }
  #gameCanvas {
    background: #000;
    border: 2px solid #555;
    display: block;
    width: 100%;
    height: 100%;
  }
  #ui {
    position: absolute;
    top: 8px;
    left: 8px;
    font-size: 14px;
    text-shadow: 0 0 4px #000;
    pointer-events: none;
  }
  #gameOverText {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 28px;
    text-align: center;
    display: none;
    text-shadow: 0 0 8px #000;
    padding: 8px 12px;
    background: rgba(0,0,0,0.6);
    border-radius: 8px;
  }
  #bossHpBar {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 150px;
    height: 10px;
    border: 1px solid #fff;
    display: none;
    background: rgba(0,0,0,0.4);
  }
  #bossHpInner {
    width: 100%;
    height: 100%;
    background: red;
  }

  /* ğŸ”¥ ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ì „ì²´ ì˜ì—­ */
  #mobileControls {
    position: absolute;
    bottom: 18px;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    padding: 0 18px;
    box-sizing: border-box;
    pointer-events: none; /* ì•ˆìª½ ìš”ì†Œë§Œ í„°ì¹˜ */
  }

  /* ğŸ”¥ ì¡°ì´ìŠ¤í‹± í¬ê²Œ (ëŒ€ëµ ê°€ë¡œÂ·ì„¸ë¡œ 5ë°°ì¯¤ ì²´ê°) */
  #joystickContainer {
    position: relative;
    width: 260px;
    height: 260px;
    pointer-events: auto;
    touch-action: none;
  }
  #joystickBase {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 220px;
    height: 220px;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    border: 3px solid rgba(255,255,255,0.5);
    background: rgba(255,255,255,0.07);
    box-shadow: 0 0 16px rgba(0,0,0,0.8);
  }
  #joystickStick {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 120px;
    height: 120px;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    background: rgba(255,255,255,0.5);
    box-shadow: 0 0 18px rgba(0,0,0,0.9);
  }

  /* ğŸ”¥ ê³µê²© ë²„íŠ¼ë„ ì™•í¬ê²Œ + ì†ê°€ë½ì— ì—¬ìœ  ìˆëŠ” ê°„ê²© */
  #buttonContainer {
    display: flex;
    flex-direction: column;
    gap: 18px;
    align-items: flex-end;
    pointer-events: auto;
    margin-right: 4px;
    margin-bottom: 12px;
  }
  .actionButton {
    min-width: 160px;
    padding: 20px 26px;
    font-size: 18px;
    border-radius: 999px;
    border: none;
    background: rgba(255,255,255,0.2);
    color: #fff;
    font-weight: 700;
    text-shadow: 0 0 4px #000;
    box-shadow: 0 0 14px rgba(0,0,0,0.85);
  }
  .actionButton:active {
    transform: scale(0.95);
    background: rgba(255,255,255,0.3);
  }

  /* PC ê°™ì€ í° í™”ë©´ì—ì„œëŠ” ë„ˆë¬´ ê±°ëŒ€í•´ì§€ì§€ ì•Šê²Œ ì¡°ê¸ˆ ì¶•ì†Œ */
  @media (min-width: 900px) {
    #joystickContainer {
      width: 200px;
      height: 200px;
    }
    #joystickBase {
      width: 170px;
      height: 170px;
    }
    #joystickStick {
      width: 90px;
      height: 90px;
    }
    .actionButton {
      min-width: 140px;
      padding: 16px 22px;
      font-size: 16px;
    }
  }
</style>

</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="720" height="850"></canvas>

    <div id="ui">
      ì ìˆ˜: <span id="score">0</span><br />
      ëª©ìˆ¨: <span id="lives">3</span><br />
      íŒŒì›Œ: <span id="power">0</span> / 3<br />
      í•„ì‚´ê¸°(Z): 3ì´ˆ ì¿¨íƒ€ì„<br />
      ê·¼ì ‘(X): ì§§ì€ ì¿¨íƒ€ì„
    </div>
    <div id="bossHpBar">
      <div id="bossHpInner"></div>
    </div>
    <div id="gameOverText"></div>

    <!-- ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ -->
    <div id="mobileControls">
      <div id="joystickContainer">
        <div id="joystickBase"></div>
        <div id="joystickStick"></div>
      </div>
      <div id="buttonContainer">
        <button class="actionButton" id="btnShoot">SHOT</button>
        <button class="actionButton" id="btnMelee">MELEE</button>
        <button class="actionButton" id="btnBomb">BOMB</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const livesEl = document.getElementById("lives");
    const powerEl = document.getElementById("power");
    const gameOverText = document.getElementById("gameOverText");
    const bossHpBar = document.getElementById("bossHpBar");
    const bossHpInner = document.getElementById("bossHpInner");

    const joystickContainer = document.getElementById("joystickContainer");
    const joystickBase = document.getElementById("joystickBase");
    const joystickStick = document.getElementById("joystickStick");
    const btnShoot = document.getElementById("btnShoot");
    const btnMelee = document.getElementById("btnMelee");
    const btnBomb = document.getElementById("btnBomb");

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    // ê³ ì–‘ì´ íƒ€ì… ì •ì˜
    const CAT_TYPES = {
      cheese: {
        id: "cheese",
        name: "ì¹˜ì¦ˆëƒ¥",
        furColor: "#ffcc80",
        earInner: "#ffb74d",
        speed: 6,
        bulletSpeed: 9,
        homingCount: 1,
        desc: "ê· í˜•í˜•: ê¸°ë™ì„±/íƒ„ì†/ìœ ë„íƒ„ ëª¨ë‘ í‰ê· "
      },
      black: {
        id: "black",
        name: "ê²€ì€ëƒ¥",
        furColor: "#444",
        earInner: "#757575",
        speed: 7.6,
        bulletSpeed: 9,
        homingCount: 1,
        desc: "ê³ ê¸°ë™: ì´ë™ì†ë„ ë¹ ë¦„, ìœ ë„íƒ„ 1ê°œ"
      },
      party: {
        id: "party",
        name: "íŒŒí‹°ëƒ¥",
        furColor: "#f48fb1",
        earInner: "#ff80ab",
        speed: 6,
        bulletSpeed: 10,
        homingCount: 2,
        desc: "í™”ë ¥í˜•: íƒ„ì† ë¹ ë¥´ê³  ìœ ë„íƒ„ 2ê°œ"
      }
    };

    const catOptions = [
      { id: "cheese", x: WIDTH/2 - 200, y: HEIGHT/2, w: 140, h: 220 },
      { id: "black",  x: WIDTH/2,       y: HEIGHT/2, w: 140, h: 220 },
      { id: "party",  x: WIDTH/2 + 200, y: HEIGHT/2, w: 140, h: 220 }
    ];

    let selectedCatType = null;
    let selectedCat = null;
    let hasSelectedCat = false;

    // í”Œë ˆì´ì–´
    const player = {
      x: WIDTH / 2,
      y: HEIGHT - 150,
      width: 46,
      height: 52,
      speed: 6,
    };

    let bullets = [];
    let enemies = [];
    let enemyBullets = [];
    let powerUps = [];
    let keys = {};
    let score = 0;
    let lives = 3;
    let powerLevel = 0; // 0~3
    let gameOver = false;
    let lastEnemySpawn = 0;
    let enemySpawnInterval = 900;

    let lastTime = 0;
    let totalElapsed = 0;

    let boss = null;
    const BOSS_SPAWN_TIME = 60000; // 60ì´ˆ í›„ ë³´ìŠ¤ ë“±ì¥
    const BOSS_PATTERN_CHANGE_TIME = 4000;

    let lastBombTime = 0;
    const BOMB_COOLDOWN = 3000;

    let meleeActive = false;
    let meleeEndTime = 0;
    let lastMeleeTime = 0;
    const MELEE_DURATION = 150;
    const MELEE_COOLDOWN = 400;

    let isVictory = false;

    // ===== í‚¤ë³´ë“œ ì…ë ¥ =====
    window.addEventListener("keydown", (e) => {
      keys[e.code] = true;

      if (gameOver && e.code === "Space") {
        restartGame();
      }

      if (!gameOver && hasSelectedCat) {
        if (e.code === "KeyZ") useBomb();
        if (e.code === "KeyX") useMelee();
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.code] = false;
    });

    // ìº”ë²„ìŠ¤ í´ë¦­/í„°ì¹˜ â†’ ì˜¤í”„ë‹ì—ì„œ ìºë¦­í„° ì„ íƒ, ê²Œì„ì˜¤ë²„ì¼ ë• ì¬ì‹œì‘
    function getCanvasPos(evt) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      if (evt.touches && evt.touches[0]) {
        clientX = evt.touches[0].clientX;
        clientY = evt.touches[0].clientY;
      } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
      }
      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);
      return { x, y };
    }

    function handleCanvasPointer(evt) {
      evt.preventDefault();
      const pos = getCanvasPos(evt);

      if (!hasSelectedCat) {
        // ìºë¦­í„° ì„ íƒ
        for (const opt of catOptions) {
          if (
            pos.x > opt.x - opt.w/2 &&
            pos.x < opt.x + opt.w/2 &&
            pos.y > opt.y - opt.h/2 &&
            pos.y < opt.y + opt.h/2
          ) {
            selectCat(opt.id);
            return;
          }
        }
      } else if (gameOver) {
        restartGame();
      }
    }

    canvas.addEventListener("click", handleCanvasPointer);
    canvas.addEventListener("touchstart", handleCanvasPointer, { passive: false });

    // ===== ì¡°ì´ìŠ¤í‹± =====
    const joystickState = {
      active: false,
      centerX: 0,
      centerY: 0,
    };

    function updateDirFromJoystick(dx, dy) {
      const dead = 10;
      keys["ArrowLeft"] = false;
      keys["ArrowRight"] = false;
      keys["ArrowUp"] = false;
      keys["ArrowDown"] = false;

      const dist = Math.hypot(dx, dy);
      if (dist < dead) return;

      if (dx < -dead) keys["ArrowLeft"] = true;
      if (dx > dead) keys["ArrowRight"] = true;
      if (dy < -dead) keys["ArrowUp"] = true;
      if (dy > dead) keys["ArrowDown"] = true;
    }

    function resetJoystickStickPosition() {
      joystickStick.style.left = "50%";
      joystickStick.style.top = "50%";
      joystickStick.style.transform = "translate(-50%, -50%)";
    }

    function handleJoystickTouchStart(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = joystickBase.getBoundingClientRect();
      joystickState.centerX = rect.left + rect.width / 2;
      joystickState.centerY = rect.top + rect.height / 2;
      joystickState.active = true;
      handleJoystickTouchMove(e);
    }

    function handleJoystickTouchMove(e) {
      if (!joystickState.active) return;
      e.preventDefault();
      const touch = e.touches[0];
      const dx = touch.clientX - joystickState.centerX;
      const dy = touch.clientY - joystickState.centerY;

      const maxRadius = 50;
      let dist = Math.hypot(dx, dy);
      let ndx = dx;
      let ndy = dy;
      if (dist > maxRadius) {
        ndx = (dx / dist) * maxRadius;
        ndy = (dy / dist) * maxRadius;
      }

      joystickStick.style.left = 50 + (ndx / maxRadius) * 50 + "%";
      joystickStick.style.top = 50 + (ndy / maxRadius) * 50 + "%";
      joystickStick.style.transform = "translate(-50%, -50%)";

      updateDirFromJoystick(dx, dy);
    }

    function handleJoystickTouchEnd(e) {
      e.preventDefault();
      joystickState.active = false;
      resetJoystickStickPosition();
      updateDirFromJoystick(0, 0);
    }

    joystickContainer.addEventListener("touchstart", handleJoystickTouchStart, { passive: false });
    joystickContainer.addEventListener("touchmove", handleJoystickTouchMove, { passive: false });
    joystickContainer.addEventListener("touchend", handleJoystickTouchEnd, { passive: false });
    joystickContainer.addEventListener("touchcancel", handleJoystickTouchEnd, { passive: false });

    resetJoystickStickPosition();

    // ëª¨ë°”ì¼ ë²„íŠ¼: SHOT(í™€ë“œ), MELEE/BOMB(íƒ­)
    function attachButtonHold(button, keyCode) {
      const down = (e) => {
        e.preventDefault();
        keys[keyCode] = true;
      };
      const up = (e) => {
        e.preventDefault();
        keys[keyCode] = false;
      };
      button.addEventListener("touchstart", down, { passive: false });
      button.addEventListener("touchend", up, { passive: false });
      button.addEventListener("touchcancel", up, { passive: false });
      button.addEventListener("mousedown", down);
      window.addEventListener("mouseup", up);
    }
    attachButtonHold(btnShoot, "Space");

    function attachSkillTap(button, skillFn) {
      button.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (!gameOver && hasSelectedCat) skillFn();
      }, { passive: false });
      button.addEventListener("click", (e) => {
        e.preventDefault();
        if (!gameOver && hasSelectedCat) skillFn();
      });
    }
    attachSkillTap(btnMelee, () => useMelee());
    attachSkillTap(btnBomb, () => useBomb());

    // ===== ê²Œì„ ë¡œì§ =====

    function selectCat(id) {
      selectedCatType = id;
      selectedCat = CAT_TYPES[id];
      hasSelectedCat = true;

      player.speed = selectedCat.speed;
      // ì´ˆê¸°í™” & ì‹œì‘
      restartGameInternal(false); // ë‚´ë¶€ ë¦¬ì…‹ (ì—”ë”© í…ìŠ¤íŠ¸ ì—†ì´)
    }

    function shoot() {
      if (!selectedCat) return;
      const count = 1 + powerLevel;
      const spread = 8;
      const mid = (count - 1) / 2;
      const bulletSpeed = selectedCat.bulletSpeed;
      const homingCount = selectedCat.homingCount;

      // íŒŒì›Œ 3ë‹¨ê³„ì—ì„œë§Œ ìœ ë„íƒ„ í™œì„±
      let homingIndices = [];
      if (powerLevel >= 3) {
        const hc = Math.min(homingCount, count);
        const start = Math.round(mid - (hc - 1) / 2);
        for (let k = 0; k < hc; k++) homingIndices.push(start + k);
      }

      for (let i = 0; i < count; i++) {
        const offset = (i - mid) * spread;
        const isHoming = homingIndices.includes(i);

        bullets.push({
          x: player.x + offset,
          y: player.y - player.height / 2,
          width: 6,
          height: 12,
          speed: bulletSpeed,
          color: isHoming ? "#80d8ff" : "#ffeb3b",
          homing: isHoming,
          target: null,
          vx: 0,
          vy: -bulletSpeed,
        });
      }
    }

    function spawnEnemy() {
      const enemyWidth = 38;
      const x = Math.random() * (WIDTH - enemyWidth) + enemyWidth / 2;
      const pattern = Math.floor(Math.random() * 3);

      enemies.push({
        x,
        y: -30,
        width: enemyWidth,
        height: enemyWidth * 1.2,
        speed: 1.8 + Math.random() * 2.4,
        color: "#90caf9",
        lastShot: performance.now(),
        shotInterval: 700 + Math.random() * 900,
        canDropPower: Math.random() < 0.25,
        pattern,
        phase: 0,
        dirX: Math.random() < 0.5 ? -1 : 1,
        dead: false,
      });
    }

    function spawnBoss() {
      boss = {
        x: WIDTH / 2,
        y: 140,
        width: 170,
        height: 90,
        hp: 380,
        maxHp: 380,
        speedX: 3.2,
        lastShot: performance.now(),
        shotInterval: 160,
        dead: false,
        pattern: 0,
        patternTimer: 0,
      };
      bossHpBar.style.display = "block";
      updateBossHpBar();
    }

    function updateBossHpBar() {
      if (!boss) return;
      bossHpInner.style.width = (boss.hp / boss.maxHp) * 100 + "%";
    }

    function showEndText() {
      if (isVictory) {
        gameOverText.innerHTML =
          "VICTORY!<br/>ë³´ìŠ¤ë¥¼ ë¬¼ë¦¬ì³¤ë‹¤!<br/><div style='margin-top:8px;font-size:16px;'>í™”ë©´ì„ í„°ì¹˜í•˜ê±°ë‚˜ ìŠ¤í˜ì´ìŠ¤ë¥¼ ëˆŒëŸ¬ ì¬ì‹œì‘</div>";
      } else {
        gameOverText.innerHTML =
          "GAME OVER<br/><div style='margin-top:8px;font-size:16px;'>í™”ë©´ì„ í„°ì¹˜í•˜ê±°ë‚˜ ìŠ¤í˜ì´ìŠ¤ë¥¼ ëˆŒëŸ¬ ì¬ì‹œì‘</div>";
      }
      gameOverText.style.display = "block";
    }

    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) endGame(false);
    }

    function endGame(win) {
      gameOver = true;
      isVictory = !!win;
      bossHpBar.style.display = "none";
      showEndText();
    }

    function restartGameInternal(resetCatToo) {
      bullets = [];
      enemies = [];
      enemyBullets = [];
      powerUps = [];
      score = 0;
      lives = 3;
      powerLevel = 0;
      enemySpawnInterval = 900;
      totalElapsed = 0;
      boss = null;
      scoreEl.textContent = score;
      livesEl.textContent = lives;
      powerEl.textContent = powerLevel;
      bossHpBar.style.display = "none";
      gameOver = false;
      isVictory = false;
      player.x = WIDTH / 2;
      player.y = HEIGHT - 150;
      gameOverText.style.display = "none";
      lastTime = performance.now();
      meleeActive = false;

      if (resetCatToo) {
        hasSelectedCat = false;
        selectedCat = null;
        selectedCatType = null;
      }
    }

    function restartGame() {
      // ê³ ì–‘ì´ëŠ” ìœ ì§€í•œ ì±„ ë‹¤ì‹œ ì‹œì‘
      restartGameInternal(false);
    }

    function rectsCollide(a, b) {
      return !(
        a.x + a.width / 2 < b.x - b.width / 2 ||
        a.x - a.width / 2 > b.x + b.width / 2 ||
        a.y + a.height / 2 < b.y - b.height / 2 ||
        a.y - a.height / 2 > b.y + b.height / 2
      );
    }

    function acquireTarget(bullet) {
      let candidates = [];
      for (const e of enemies) {
        if (!e.dead) candidates.push(e);
      }
      if (boss && !boss.dead) candidates.push(boss);
      if (!candidates.length) return null;

      let best = null;
      let bestDist = Infinity;
      for (const t of candidates) {
        const dx = t.x - bullet.x;
        const dy = t.y - bullet.y;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestDist) {
          bestDist = d2;
          best = t;
        }
      }
      return best;
    }

    function useBomb() {
      if (!hasSelectedCat) return;
      const now = performance.now();
      if (now - lastBombTime < BOMB_COOLDOWN) return;
      lastBombTime = now;

      enemies.forEach(e => e.dead = true);
      enemies = [];

      enemyBullets.forEach(b => b.dead = true);
      enemyBullets = [];

      if (boss) {
        boss.hp = 0;
        boss.dead = true;
        updateBossHpBar();
        score += 2000;
        scoreEl.textContent = score;
        boss = null;
        endGame(true);
      }
    }

    function useMelee() {
      if (!hasSelectedCat) return;
      const now = performance.now();
      if (now - lastMeleeTime < MELEE_COOLDOWN) return;
      lastMeleeTime = now;
      meleeActive = true;
      meleeEndTime = now + MELEE_DURATION;
    }

    function bossShootPattern() {
      if (!boss || boss.dead) return;
      const shotsBaseY = boss.y + boss.height / 2;

      if (boss.pattern === 0) {
        const shots = 18;
        const baseAngle = Math.PI / 2;
        const spread = 0.9;
        const safeIndex = 7 + Math.floor(Math.random() * 3);
        const extraGap = Math.random() < 0.4;
        const safeIndex2 = extraGap ? safeIndex + 3 : -1;

        for (let i = 0; i < shots; i++) {
          if (i === safeIndex || i === safeIndex2) continue;
          const t = i / (shots - 1) - 0.5;
          const angle = baseAngle + t * spread;
          enemyBullets.push({
            x: boss.x,
            y: shotsBaseY,
            width: 6,
            height: 12,
            vx: Math.cos(angle) * 5.0,
            vy: Math.sin(angle) * 5.0,
            color: "#ffeb3b",
          });
        }
      } else if (boss.pattern === 1) {
        const columns = 12;
        const margin = 40;
        const step = (WIDTH - margin * 2) / (columns - 1);
        const safeCol = Math.floor(Math.random() * columns);
        const extraSafe = (Math.random() < 0.5)
          ? Math.min(columns - 1, safeCol + 2)
          : -1;

        for (let i = 0; i < columns; i++) {
          if (i === safeCol || i === extraSafe) continue;
          const xPos = margin + i * step;
          enemyBullets.push({
            x: xPos,
            y: shotsBaseY,
            width: 6,
            height: 14,
            vx: 0,
            vy: 5.5,
            color: "#ffb74d",
          });
        }
      } else if (boss.pattern === 2) {
        const burstCount = 3;
        for (let b = 0; b < burstCount; b++) {
          const dx = player.x - boss.x;
          const dy = player.y - shotsBaseY;
          const baseLen = Math.hypot(dx, dy) || 1;
          const baseAngle = Math.atan2(dy, dx);
          const spread = 0.15;

          for (let i = -1; i <= 1; i++) {
            const angle = baseAngle + i * spread;
            const speed = 5.8;
            enemyBullets.push({
              x: boss.x,
              y: shotsBaseY,
              width: 6,
              height: 12,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              color: "#ff4081",
            });
          }
        }
      }
    }

    function update(delta) {
      if (gameOver || !hasSelectedCat) return;
      const now = performance.now();
      totalElapsed += delta;

      if (meleeActive && now > meleeEndTime) {
        meleeActive = false;
      }

      if (!boss && totalElapsed >= BOSS_SPAWN_TIME) {
        spawnBoss();
      }

      if (keys["ArrowLeft"]) player.x -= player.speed;
      if (keys["ArrowRight"]) player.x += player.speed;
      if (keys["ArrowUp"]) player.y -= player.speed;
      if (keys["ArrowDown"]) player.y += player.speed;

      if (player.x < player.width / 2) player.x = player.width / 2;
      if (player.x > WIDTH - player.width / 2) player.x = WIDTH - player.width / 2;
      if (player.y < player.height / 2) player.y = player.height / 2;
      if (player.y > HEIGHT - player.height / 2) player.y = HEIGHT - player.height / 2;

      if (keys["Space"]) {
        if (!shoot.cooldown || now - shoot.cooldown > 200) {
          shoot();
          shoot.cooldown = now;
        }
      }

      bullets.forEach((b) => {
        if (b.homing) {
          if (!b.target) {
            b.target = acquireTarget(b);
          }
          if (b.target && !b.target.dead) {
            const dx = b.target.x - b.x;
            const dy = b.target.y - b.y;
            const L = Math.hypot(dx, dy) || 1;
            b.vx = (dx / L) * b.speed;
            b.vy = (dy / L) * b.speed;
          } else if (b.target) {
            b.homing = false;
          }
        }
        b.x += b.vx || 0;
        b.y += b.vy || -b.speed;
      });

      bullets = bullets.filter(
        (b) =>
          b.x > -50 &&
          b.x < WIDTH + 50 &&
          b.y > -50 &&
          b.y < HEIGHT + 50 &&
          !b.dead
      );

      lastEnemySpawn += delta;
      if (lastEnemySpawn > enemySpawnInterval) {
        spawnEnemy();
        lastEnemySpawn = 0;
        enemySpawnInterval = Math.max(350, enemySpawnInterval - 2);
      }

      enemies.forEach((e) => {
        if (e.pattern === 0) {
          e.y += e.speed;
        } else if (e.pattern === 1) {
          e.y += e.speed * 0.9;
          e.phase += 0.09;
          e.x += Math.sin(e.phase) * 3.2;
        } else if (e.pattern === 2) {
          e.y += e.speed * 1.35;
          e.x += e.dirX * 2.7;
          if (e.x < e.width / 2 || e.x > WIDTH - e.width / 2) {
            e.dirX *= -1;
          }
        }

        if (now - e.lastShot > e.shotInterval) {
          e.lastShot = now;
          if (e.pattern === 0) {
            for (let n = 0; n < 2; n++) {
              const dx = player.x - e.x;
              const dy = player.y - e.y;
              const L = Math.hypot(dx, dy) || 1;
              enemyBullets.push({
                x: e.x,
                y: e.y,
                width: 6,
                height: 12,
                vx: (dx / L) * 4.3,
                vy: (dy / L) * 4.3,
                color: "#ff5252",
              });
            }
          } else if (e.pattern === 1) {
            const baseAngle = Math.PI / 2;
            const spread = 0.22;
            for (let i = -2; i <= 2; i++) {
              const angle = baseAngle + i * spread;
              enemyBullets.push({
                x: e.x,
                y: e.y,
                width: 6,
                height: 12,
                vx: Math.cos(angle) * 3.7,
                vy: Math.sin(angle) * 3.7,
                color: "#ff8a65",
              });
            }
          } else if (e.pattern === 2) {
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const L = Math.hypot(dx, dy) || 1;
            enemyBullets.push({
              x: e.x,
              y: e.y,
              width: 6,
              height: 12,
              vx: (dx / L) * 6.0,
              vy: (dy / L) * 6.0,
              color: "#ff4081",
            });
          }
        }

        if (e.y - e.height / 2 > HEIGHT) {
          e.dead = true;
        }
      });

      enemies = enemies.filter((e) => !e.dead);

      if (boss) {
        boss.x += boss.speedX;
        if (boss.x - boss.width / 2 < 0 || boss.x + boss.width / 2 > WIDTH) {
          boss.speedX *= -1;
        }

        boss.patternTimer += delta;
        if (boss.patternTimer > BOSS_PATTERN_CHANGE_TIME) {
          boss.patternTimer = 0;
          boss.pattern = (boss.pattern + 1) % 3;
        }

        if (!boss.dead && now - boss.lastShot > boss.shotInterval) {
          boss.lastShot = now;
          bossShootPattern();
        }
      }

      enemyBullets.forEach((b) => {
        b.x += b.vx;
        b.y += b.vy;
      });

      if (meleeActive) {
        const rangeX = 140;
        const rangeY = 160;
        enemyBullets.forEach((b) => {
          if (b.dead) return;
          if (
            b.y < player.y &&
            player.y - b.y < rangeY &&
            Math.abs(b.x - player.x) < rangeX / 2
          ) {
            b.dead = true;
          }
        });
      }

      enemyBullets = enemyBullets.filter(
        (b) =>
          b.x > -50 &&
          b.x < WIDTH + 50 &&
          b.y > -50 &&
          b.y < HEIGHT + 50 &&
          !b.dead
      );

      powerUps.forEach((p) => {
        p.y += p.speed;
      });
      powerUps = powerUps.filter((p) => p.y < HEIGHT + 30 && !p.dead);

      bullets.forEach((b) => {
        enemies.forEach((e) => {
          if (!b.dead && !e.dead && rectsCollide(b, e)) {
            b.dead = true;
            e.dead = true;
            score += 10;
            scoreEl.textContent = score;

            if (e.canDropPower) {
              powerUps.push({
                x: e.x,
                y: e.y,
                radius: 12,
                speed: 3,
                color: "#82b1ff",
                dead: false,
              });
            }
          }
        });

        if (boss && !boss.dead && !b.dead && rectsCollide(b, boss)) {
          b.dead = true;
          boss.hp -= 2;
          if (boss.hp <= 0) {
            boss.hp = 0;
            boss.dead = true;
            updateBossHpBar();
            score += 2000;
            scoreEl.textContent = score;
            boss = null;
            endGame(true);
          } else {
            updateBossHpBar();
          }
        }
      });

      bullets = bullets.filter((b) => !b.dead);
      enemies = enemies.filter((e) => !e.dead);

      enemyBullets.forEach((b) => {
        if (!b.dead && rectsCollide(player, b)) {
          b.dead = true;
          loseLife();
        }
      });
      enemyBullets = enemyBullets.filter((b) => !b.dead);

      enemies.forEach((e) => {
        if (!e.dead && rectsCollide(player, e)) {
          e.dead = true;
          loseLife();
        }
      });
      enemies = enemies.filter((e) => !e.dead);

      powerUps.forEach((p) => {
        const dx = p.x - player.x;
        const dy = p.y - player.y;
        if (Math.hypot(dx, dy) < p.radius + player.width / 2) {
          p.dead = true;
          if (powerLevel < 3) {
            powerLevel++;
            powerEl.textContent = powerLevel;
          }
        }
      });
      powerUps = powerUps.filter((p) => !p.dead);
    }

    // ê³ ì–‘ì´ ê·¸ë¦¬ê¸° (ìƒ‰ë§Œ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¥´ê²Œ)
    function drawCatBody(cx, cy, w, h, cat) {
      const fur = cat ? cat.furColor : "#ffcc80";
      const earIn = cat ? cat.earInner : "#ff8a80";

      ctx.save();
      ctx.translate(cx, cy);

      ctx.fillStyle = fur;
      ctx.beginPath();
      ctx.ellipse(0, h * 0.15, w * 0.35, h * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.beginPath();
      ctx.arc(0, -h * 0.15, w * 0.3, 0, Math.PI * 2);
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(-w * 0.2, -h * 0.45);
      ctx.lineTo(-w * 0.05, -h * 0.25);
      ctx.lineTo(-w * 0.32, -h * 0.25);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(w * 0.2, -h * 0.45);
      ctx.lineTo(w * 0.05, -h * 0.25);
      ctx.lineTo(w * 0.32, -h * 0.25);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = earIn;
      ctx.beginPath();
      ctx.moveTo(-w * 0.19, -h * 0.4);
      ctx.lineTo(-w * 0.08, -h * 0.27);
      ctx.lineTo(-w * 0.28, -h * 0.27);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(w * 0.19, -h * 0.4);
      ctx.lineTo(w * 0.08, -h * 0.27);
      ctx.lineTo(w * 0.28, -h * 0.27);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(-w * 0.12, -h * 0.16, w * 0.04, 0, Math.PI * 2);
      ctx.arc(w * 0.12, -h * 0.16, w * 0.04, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(-w * 0.13, -h * 0.17, w * 0.015, 0, Math.PI * 2);
      ctx.arc(w * 0.11, -h * 0.17, w * 0.015, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#d81b60";
      ctx.beginPath();
      ctx.moveTo(0, -h * 0.1);
      ctx.lineTo(-w * 0.03, -h * 0.07);
      ctx.lineTo(w * 0.03, -h * 0.07);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "#d81b60";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(0, -h * 0.07);
      ctx.lineTo(0, -h * 0.05);
      ctx.moveTo(0, -h * 0.05);
      ctx.quadraticCurveTo(-w * 0.03, -h * 0.03, -w * 0.06, -h * 0.02);
      ctx.moveTo(0, -h * 0.05);
      ctx.quadraticCurveTo(w * 0.03, -h * 0.03, w * 0.06, -h * 0.02);
      ctx.stroke();

      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-w * 0.06, -h * 0.11);
      ctx.lineTo(-w * 0.18, -h * 0.11);
      ctx.moveTo(-w * 0.06, -h * 0.095);
      ctx.lineTo(-w * 0.18, -h * 0.075);
      ctx.moveTo(w * 0.06, -h * 0.11);
      ctx.lineTo(w * 0.18, -h * 0.11);
      ctx.moveTo(w * 0.06, -h * 0.095);
      ctx.lineTo(w * 0.18, -h * 0.075);
      ctx.stroke();

      ctx.fillStyle = fur;
      ctx.beginPath();
      ctx.ellipse(-w * 0.13, h * 0.4, w * 0.07, h * 0.1, 0, 0, Math.PI * 2);
      ctx.ellipse(w * 0.13, h * 0.4, w * 0.07, h * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = fur;
      ctx.lineWidth = 6;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(w * 0.3, h * 0.1);
      ctx.quadraticCurveTo(w * 0.45, h * 0.25, w * 0.25, h * 0.4);
      ctx.stroke();

      ctx.restore();
    }

    function drawPlayer() {
      if (!hasSelectedCat || !selectedCat) return;
      drawCatBody(player.x, player.y, player.width, player.height, selectedCat);
    }

    function drawMelee() {
      if (!meleeActive) return;
      const w = player.width;
      const h = player.height;
      const cx = player.x;
      const cy = player.y;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.fillStyle = "rgba(255, 255, 0, 0.35)";
      ctx.beginPath();
      ctx.arc(0, -h * 0.1, w * 1.4, Math.PI * 1.1, Math.PI * 1.9);
      ctx.arc(0, -h * 0.1, w * 0.5, Math.PI * 1.9, Math.PI * 1.1, true);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawBullets() {
      bullets.forEach((b) => {
        ctx.fillStyle = b.color;
        ctx.fillRect(
          b.x - b.width / 2,
          b.y - b.height / 2,
          b.width,
          b.height
        );
      });
    }

    function drawEnemies() {
      enemies.forEach((e) => {
        const w = e.width;
        const h = e.height;
        ctx.save();
        ctx.translate(e.x, e.y);

        ctx.fillStyle = e.color;
        ctx.beginPath();
        ctx.moveTo(0, -h / 2);
        ctx.lineTo(-w * 0.18, -h * 0.1);
        ctx.lineTo(-w * 0.14, h * 0.45);
        ctx.lineTo(0, h * 0.35);
        ctx.lineTo(w * 0.14, h * 0.45);
        ctx.lineTo(w * 0.18, -h * 0.1);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#e3f2fd";
        ctx.beginPath();
        ctx.moveTo(-w * 0.5, 0);
        ctx.lineTo(-w * 0.12, h * 0.05);
        ctx.lineTo(-w * 0.12, h * 0.25);
        ctx.lineTo(-w * 0.5, h * 0.1);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(w * 0.5, 0);
        ctx.lineTo(w * 0.12, h * 0.05);
        ctx.lineTo(w * 0.12, h * 0.25);
        ctx.lineTo(w * 0.5, h * 0.1);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#bbdefb";
        ctx.beginPath();
        ctx.moveTo(-w * 0.15, h * 0.25);
        ctx.lineTo(-w * 0.05, h * 0.5);
        ctx.lineTo(0, h * 0.35);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(w * 0.15, h * 0.25);
        ctx.lineTo(w * 0.05, h * 0.5);
        ctx.lineTo(0, h * 0.35);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#1e88e5";
        ctx.beginPath();
        ctx.ellipse(0, -h * 0.15, w * 0.15, h * 0.18, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      });
    }

    function drawEnemyBullets() {
      enemyBullets.forEach((b) => {
        ctx.fillStyle = b.color;
        ctx.fillRect(
          b.x - b.width / 2,
          b.y - b.height / 2,
          b.width,
          b.height
        );
      });
    }

    function drawPowerUps() {
      powerUps.forEach((p) => {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.beginPath();
        ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
        ctx.restore();
      });
    }

    function drawBoss() {
      if (!boss) return;
      ctx.save();
      ctx.translate(boss.x, boss.y);
      ctx.fillStyle = "#9c27b0";
      ctx.fillRect(-boss.width / 2, -boss.height / 2, boss.width, boss.height);

      ctx.fillStyle = "#fff";
      ctx.fillRect(-boss.width / 4 - 10, -boss.height / 4, 20, 10);
      ctx.fillRect(boss.width / 4 - 10, -boss.height / 4, 20, 10);
      ctx.restore();
    }

    // ì˜¤í”„ë‹ í™”ë©´
    function drawOpeningScreen() {
      ctx.save();
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      const title = "ëª¨ë°”ì¼ëƒ¥ì½”ëŒ€ì „!";
      ctx.fillStyle = "#fff";
      ctx.font = "bold 48px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(title, WIDTH / 2, HEIGHT * 0.18);

      ctx.font = "18px system-ui";
      ctx.fillStyle = "#ddd";
      ctx.fillText("ê³ ì–‘ì´ë¥¼ í„°ì¹˜í•´ì„œ ì„ íƒí•˜ì„¸ìš”", WIDTH / 2, HEIGHT * 0.25);

      catOptions.forEach((opt) => {
        const cat = CAT_TYPES[opt.id];
        const x = opt.x;
        const y = opt.y;
        const w = opt.w;
        const h = opt.h;

        // ì¹´ë“œ ë°°ê²½
        ctx.fillStyle = "rgba(255,255,255,0.06)";
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(x - w/2, y - h/2, w, h, 16);
        ctx.fill();
        ctx.stroke();

        // ê³ ì–‘ì´ ê·¸ë¦¼
        drawCatBody(x, y - 40, 40, 46, cat);

        // ì´ë¦„
        ctx.fillStyle = "#fff";
        ctx.font = "bold 20px system-ui";
        ctx.fillText(cat.name, x, y + 40);

        // ì„¤ëª… (ë‘ ì¤„ ì •ë„)
        ctx.fillStyle = "#ccc";
        ctx.font = "12px system-ui";
        const lines = cat.desc.split(" ");
        // ê°„ë‹¨íˆ ë‘ ì¤„ë¡œ ë‚˜ëˆ”
        ctx.fillText(lines[0], x, y + 65);
        ctx.fillText(lines.slice(1).join(" "), x, y + 83);
      });

      ctx.restore();
    }

    function gameLoop(t) {
      if (!lastTime) lastTime = t;
      const dt = t - lastTime;
      lastTime = t;

      ctx.clearRect(0, 0, WIDTH, HEIGHT);

      if (!hasSelectedCat) {
        drawOpeningScreen();
      } else {
        update(dt);
        drawPlayer();
        drawMelee();
        drawBullets();
        drawEnemies();
        drawEnemyBullets();
        drawPowerUps();
        drawBoss();
      }

      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>

