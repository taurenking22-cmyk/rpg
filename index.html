<!DOCTYPE html>
<html lang="ko">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<head>
  
  <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>íƒ‘ë·° RPG - ì§ì—… ì„ íƒ & ëª¨ë°”ì¼ ì§€ì›</title>
  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #fff;
      font-family: system-ui, sans-serif;
      overflow: hidden;
    }
    #gameWrapper {
      text-align: center;
      position: relative;
    }
    canvas {
      background: #333;
      border: 3px solid #555;
      image-rendering: pixelated;
    }
    #info {
      margin-top: 8px;
      font-size: 14px;
    }

    /* ì§ì—… ì„ íƒ ì˜¤ë²„ë ˆì´ */
    #jobSelectOverlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, rgba(40,40,40,0.95), rgba(0,0,0,0.98));
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      color: #fff;
      font-family: system-ui, sans-serif;
    }

    .job-panel {
      text-align: center;
      max-width: 800px;
      padding: 24px;
      background: rgba(20,20,20,0.9);
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(0,0,0,0.8);
    }

    .job-panel h1 {
      margin-top: 0;
      margin-bottom: 8px;
    }

    .job-cards {
      display: flex;
      gap: 16px;
      margin-top: 16px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .job-card {
      width: 180px;
      padding: 16px;
      background: #333;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s, border-color 0.15s;
      border: 2px solid transparent;
    }
    .job-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 16px rgba(0,0,0,0.6);
      background: #3b3b3b;
      border-color: #00bcd4;
    }
    .job-icon {
      font-size: 32px;
      margin-bottom: 8px;
    }
    .warrior-icon { color: #ff7043; }
    .mage-icon    { color: #64b5f6; }
    .archer-icon  { color: #aed581; }

    .job-card h2 {
      margin: 4px 0;
    }
    .job-card p {
      font-size: 13px;
      color: #ddd;
      margin: 4px 0 0 0;
    }
    .job-tip {
      margin-top: 12px;
      font-size: 13px;
      color: #ccc;
    }

    /* ëª¨ë°”ì¼ ì¡°ì‘ UI */
    #mobileControls {
      position: fixed;
      inset: auto 0 8px 0;
      display: flex;
      justify-content: space-between;
      padding: 0 16px;
      pointer-events: none;
      z-index: 5;
    }

  

    #mobileControls .dpad,
    #mobileControls .actions {
      pointer-events: auto;
    }

    .dpad {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    .dpad .row {
      display: flex;
      gap: 4px;
    }

    .btn-dir,
    .btn-act {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: none;
      background: rgba(30,30,30,0.9);
      color: #fff;
      font-size: 18px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.6);
      touch-action: manipulation;
    }

    .btn-act {
      margin-left: 6px;
    }

    .btn-dir:active,
    .btn-act:active {
      transform: scale(0.92);
      background: rgba(80,80,80,0.9);
    }
  </style>
</head>
<body>
  <div id="gameWrapper">
    <canvas id="game" width="960" height="600"></canvas>
    <div id="info">
      PC: ë°©í–¥í‚¤ ì´ë™ | A: ê³µê²© | X: ìŠ¤í‚¬1 | C: ìŠ¤í‚¬2 | S: ë°©ì–´(í™€ë“œ)<br>
      ëª¨ë°”ì¼: ì•„ë˜ ë²„íŠ¼ í„°ì¹˜ë¡œ í”Œë ˆì´
    </div>
  </div>

  <!-- ì§ì—… ì„ íƒ ì˜¤ë²„ë ˆì´ -->
  <div id="jobSelectOverlay">
    <div class="job-panel">
      <h1>ì§ì—…ì„ ì„ íƒí•˜ì„¸ìš”</h1>
      <div class="job-cards">
        <div class="job-card" data-job="warrior">
          <div class="job-icon warrior-icon">ğŸ—¡</div>
          <h2>ì „ì‚¬</h2>
          <p>ë†’ì€ ì²´ë ¥ê³¼ ë°©ì–´ë ¥, ê°•ë ¥í•œ ê·¼ì ‘ ê³µê²©</p>
        </div>
        <div class="job-card" data-job="mage">
          <div class="job-icon mage-icon">ğŸ”¥</div>
          <h2>ë§ˆë²•ì‚¬</h2>
          <p>ë§ˆë²•íƒ„ê³¼ ê°•ë ¥í•œ ë§ˆë²• ìŠ¤í‚¬</p>
        </div>
        <div class="job-card" data-job="archer">
          <div class="job-icon archer-icon">ğŸ¹</div>
          <h2>ê¶ìˆ˜</h2>
          <p>ë¹ ë¥¸ ì›ê±°ë¦¬ ê³µê²©ê³¼ ê¸°ë™ì„±</p>
        </div>
      </div>
      <div class="job-tip">PCëŠ” í‚¤ë³´ë“œ, ëª¨ë°”ì¼ì€ ì•„ë˜ ë²„íŠ¼ìœ¼ë¡œ ì¡°ì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</div>
    </div>
  </div>

  <!-- ëª¨ë°”ì¼ ì „ìš© ì¡°ì‘ ë²„íŠ¼ -->
  <div id="mobileControls">
    <div class="dpad">
      <button class="btn-dir" data-dir="up">â–²</button>
      <div class="row">
        <button class="btn-dir" data-dir="left">â—€</button>
        <button class="btn-dir" data-dir="down">â–¼</button>
        <button class="btn-dir" data-dir="right">â–¶</button>
      </div>
    </div>
    <div class="actions">
      <button class="btn-act" data-act="a">A</button>
      <button class="btn-act" data-act="x">X</button>
      <button class="btn-act" data-act="c">C</button>
      <button class="btn-act" data-act="s">S</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // ===== ì›”ë“œ / ì¹´ë©”ë¼ =====
    const WORLD_WIDTH = 2000;
    const WORLD_HEIGHT = 2000;

    const camera = {
      x: 0,
      y: 0,
      w: canvas.width,
      h: canvas.height,
    };

    // ===== ì…ë ¥ =====
    const keys = {};
    window.addEventListener("keydown", (e) => {
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });

    // ëª¨ë°”ì¼ ê°€ìƒ í‚¤
    const virtualKeys = {
      ArrowUp: false,
      ArrowDown: false,
      ArrowLeft: false,
      ArrowRight: false,
      a: false,
      x: false,
      c: false,
      s: false,
    };

    function setVirtualKey(key, pressed) {
      virtualKeys[key] = pressed;
    }

    // ë°©í–¥ ë²„íŠ¼ ì´ë²¤íŠ¸
    document.querySelectorAll(".btn-dir").forEach(btn => {
      const dir = btn.getAttribute("data-dir");
      const map = { up:"ArrowUp", down:"ArrowDown", left:"ArrowLeft", right:"ArrowRight" };
      const key = map[dir];

      const press = (e) => { e.preventDefault(); setVirtualKey(key, true); };
      const release = (e) => { e.preventDefault(); setVirtualKey(key, false); };

      btn.addEventListener("touchstart", press, { passive: false });
      btn.addEventListener("touchend", release);
      btn.addEventListener("touchcancel", release);
      btn.addEventListener("mousedown", press);
      btn.addEventListener("mouseup", release);
      btn.addEventListener("mouseleave", release);
    });

    // ì•¡ì…˜ ë²„íŠ¼ ì´ë²¤íŠ¸
    document.querySelectorAll(".btn-act").forEach(btn => {
      const act = btn.getAttribute("data-act"); // a, x, c, s
      const press = (e) => { e.preventDefault(); setVirtualKey(act, true); };
      const release = (e) => { e.preventDefault(); setVirtualKey(act, false); };

      btn.addEventListener("touchstart", press, { passive: false });
      btn.addEventListener("touchend", release);
      btn.addEventListener("touchcancel", release);
      btn.addEventListener("mousedown", press);
      btn.addEventListener("mouseup", release);
      btn.addEventListener("mouseleave", release);
    });

    function isPressed(key) {
      if (key.length === 1) {
        return !!keys[key] || !!keys[key.toUpperCase()] || !!virtualKeys[key.toLowerCase()];
      }
      return !!keys[key] || !!virtualKeys[key];
    }

    // ===== ìœ í‹¸ =====
    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }
    function rectsOverlap(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    // ===== í”Œë ˆì´ì–´ =====
    const player = {
      x: WORLD_WIDTH / 2,
      y: WORLD_HEIGHT / 2,
      w: 32,
      h: 32,
      baseSpeed: 3,
      speed: 3,
      color: "#4caf50",
      hp: 100,
      maxHp: 100,
      defense: 0,
      dir: "down",

      // ê¸°ë³¸ ê³µê²© (ì „ì‚¬ìš© ê·¼ì ‘)
      isAttacking: false,
      attackTime: 0,
      attackDuration: 120,
      lastAttackTime: 0,
      attackCooldown: 250,
      baseAttackDamage: 22,
      attackDamage: 22,

      // ë ˆë²¨ / ê²½í—˜ì¹˜
      level: 1,
      xp: 0,
      xpToNext: 100,
      kills: 0,

      // ìŠ¤í‚¬ ê²Œì´ì§€
      skillGauge: 0,
      skillGaugeMax: 100,
      skillGaugeOnHit: 2.5,
      skillGaugeOnKill: 10,

      // ìŠ¤í‚¬ ì½”ìŠ¤íŠ¸/ì¿¨
      skillXCost: 40,
      skillCCost: 60,
      lastSkillXTime: 0,
      lastSkillCTime: 0,
      skillXCooldown: 1000,
      skillCCooldown: 3000,

      // ë°©ì–´ ìŠ¤í‚¬(S)
      isGuarding: false,
      guardDrainPerSec: 5, // ì´ˆë‹¹ ì†Œëª¨ (1/3ë¡œ ëŠë¦¬ê²Œ)

      // ì§ì—…ë³„ ìŠ¤í‚¬ í•¨ìˆ˜(í•„ìš”ì‹œ ë®ì–´ì”€)
      performBasicAttack: null,
      performSkillX: null,
      performSkillC: null,
    };

    let selectedJob = null;

    const JOB_STATS = {
      warrior: {
        color: "#4caf50",
        hp: 130,
        atk: 24,
        def: 2,
        spd: 3.0,
        atkCooldown: 250,
        xCost: 40,
        cCost: 60,
      },
      mage: {
        color: "#64b5f6",
        hp: 85,
        atk: 18,
        def: 0,
        spd: 2.8,
        atkCooldown: 380,
        xCost: 45,
        cCost: 65,
      },
      archer: {
        color: "#aed581",
        hp: 95,
        atk: 20,
        def: 1,
        spd: 3.5,
        atkCooldown: 160,
        xCost: 40,
        cCost: 55,
      },
    };

    function applyJobStats(jobKey) {
      const s = JOB_STATS[jobKey];
      player.color = s.color;
      player.maxHp = s.hp;
      player.hp = s.hp;
      player.attackDamage = s.atk;
      player.defense = s.def;
      player.speed = s.spd;
      player.attackCooldown = s.atkCooldown;
      player.skillXCost = s.xCost;
      player.skillCCost = s.cCost;

      // ì§ì—…ë³„ ìŠ¤í‚¬ ì„¤ì •
      if (jobKey === "warrior") {
        player.performBasicAttack = warriorBasicAttack;
        player.performSkillX = warriorSkillX;
        player.performSkillC = warriorSkillC;
      } else if (jobKey === "mage") {
        player.performBasicAttack = mageBasicAttack;
        player.performSkillX = mageSkillX;
        player.performSkillC = mageSkillC;
      } else if (jobKey === "archer") {
        player.performBasicAttack = archerBasicAttack;
        player.performSkillX = archerSkillX;
        player.performSkillC = archerSkillC;
      }
    }

    document.querySelectorAll(".job-card").forEach(card => {
      card.addEventListener("click", () => {
        const job = card.getAttribute("data-job");
        selectedJob = job;
        applyJobStats(job);
        document.getElementById("jobSelectOverlay").style.display = "none";
      });
    });

    function addSkillGauge(amount) {
      player.skillGauge = clamp(
        player.skillGauge + amount,
        0,
        player.skillGaugeMax
      );
    }

    function gainXP(amount) {
      player.xp += amount;
      while (player.xp >= player.xpToNext) {
        player.xp -= player.xpToNext;
        levelUp();
      }
    }

    function levelUp() {
      player.level += 1;
      player.maxHp += 20;
      player.attackDamage += 5;
      player.defense += 1;
      player.hp = player.maxHp;
      player.xpToNext = Math.floor(player.xpToNext * 1.5);
    }

    function damagePlayer(rawDmg) {
      if (player.isGuarding) return;
      const actual = Math.max(1, rawDmg - player.defense);
      player.hp -= actual;
      if (player.hp < 0) player.hp = 0;
    }

    // ===== ëª¬ìŠ¤í„° íƒ€ì… =====
    const MONSTER_TYPES = {
      melee: {
        name: "Melee",
        color: "#e53935",
        baseHp: 40,
        baseDamage: 8,
        speed: 1.6,
        aggroRange: 260,
        attackRange: 40,
        hitCooldown: 600,
        xpReward: 40,
      },
      ranged: {
        name: "Ranged",
        color: "#ffeb3b",
        baseHp: 30,
        baseDamage: 10,
        speed: 1.2,
        aggroRange: 320,
        attackRange: 220,
        hitCooldown: 900,
        xpReward: 50,
      },
      tank: {
        name: "Tank",
        color: "#795548",
        baseHp: 100,
        baseDamage: 15,
        speed: 0.9,
        aggroRange: 240,
        attackRange: 45,
        hitCooldown: 900,
        xpReward: 70,
      },
      fast: {
        name: "Fast",
        color: "#00bcd4",
        baseHp: 25,
        baseDamage: 7,
        speed: 2.7,
        aggroRange: 220,
        attackRange: 35,
        hitCooldown: 450,
        xpReward: 45,
      },
      bomber: {
        name: "Bomber",
        color: "#9c27b0",
        baseHp: 60,
        baseDamage: 18,
        speed: 1.1,
        aggroRange: 260,
        attackRange: 70,
        hitCooldown: 1200,
        xpReward: 70,
      },
      dragon: {
        name: "Dragon",
        color: "#ff5722",
        baseHp: 2000,
        baseDamage: 50,
        speed: 1.4,
        aggroRange: 500,
        attackRange: 400,
        hitCooldown: 900,
        xpReward: 3000,
      }
    };

    // ===== ìŠ¤í…Œì´ì§€ =====
    const STAGE_ROWS = 3;
    const STAGE_COLS = 3;
    const NUM_STAGES = STAGE_ROWS * STAGE_COLS;

    const stages = [];
    for (let i = 0; i < NUM_STAGES; i++) {
      stages.push({
        id: i,
        difficulty: i + 1,
        enemies: [],
        initialized: false,
      });
    }

    let currentStageIndex = 4; // ê°€ìš´ë°
    let enemies = stages[currentStageIndex].enemies;

    // ===== í¬íƒˆ =====
    let lastStageChangeTime = 0;
    const STAGE_CHANGE_COOLDOWN = 800;

    function getStagePos(index) {
      return {
        x: index % STAGE_COLS,
        y: Math.floor(index / STAGE_COLS),
      };
    }
    function getNeighborStage(index, dir) {
      const { x, y } = getStagePos(index);
      if (dir === "north" && y > 0) return (y - 1) * STAGE_COLS + x;
      if (dir === "south" && y < STAGE_ROWS - 1) return (y + 1) * STAGE_COLS + x;
      if (dir === "west" && x > 0) return y * STAGE_COLS + (x - 1);
      if (dir === "east" && x < STAGE_COLS - 1) return y * STAGE_COLS + (x + 1);
      return null;
    }

    function goToStage(newIndex, fromDir) {
      const now = performance.now();
      if (now - lastStageChangeTime < STAGE_CHANGE_COOLDOWN) return;
      lastStageChangeTime = now;

      const stage = stages[newIndex];
      if (!stage.initialized) {
        populateStage(stage);
      }
      currentStageIndex = newIndex;
      enemies = stages[currentStageIndex].enemies;
      enemyProjectiles.length = 0;
      skillWaves.length = 0;
      items.length = 0;
      playerProjectiles.length = 0;

      if (fromDir === "north") {
        player.y = WORLD_HEIGHT - player.h - 80;
        player.x = WORLD_WIDTH / 2 - player.w / 2;
      } else if (fromDir === "south") {
        player.y = 80;
        player.x = WORLD_WIDTH / 2 - player.w / 2;
      } else if (fromDir === "west") {
        player.x = WORLD_WIDTH - player.w - 80;
        player.y = WORLD_HEIGHT / 2 - player.h / 2;
      } else if (fromDir === "east") {
        player.x = 80;
        player.y = WORLD_HEIGHT / 2 - player.h / 2;
      }
    }

    // ===== ì  / íˆ¬ì‚¬ì²´ / ìŠ¤í‚¬ ì›¨ì´ë¸Œ / ì•„ì´í…œ / í”Œë ˆì´ì–´ íˆ¬ì‚¬ì²´ =====
    const enemyProjectiles = [];
    const skillWaves = [];
    const items = [];
    const playerProjectiles = [];

    const ITEM_TYPES = {
      attack: {
        color: "#ff9800",
        label: "ATK",
        apply() {
          player.attackDamage += 5;
        },
      },
      defense: {
        color: "#03a9f4",
        label: "DEF",
        apply() {
          player.defense += 2;
          player.maxHp += 10;
          player.hp += 10;
        },
      },
      speed: {
        color: "#8bc34a",
        label: "SPD",
        apply() {
          player.speed += 0.3;
        },
      },
    };

    function createEnemy(typeKey, stageIndex, x, y) {
      const stage = stages[stageIndex];
      const diff = stage.difficulty;
      const cfg = MONSTER_TYPES[typeKey];

      const isDragon = typeKey === "dragon";
      const hpBase = isDragon ? cfg.baseHp : cfg.baseHp * (0.7 + diff * 0.4);
      const dmgBase = isDragon ? cfg.baseDamage : cfg.baseDamage * (0.7 + diff * 0.3);

      return {
        type: typeKey,
        name: cfg.name,
        x,
        y,
        w: isDragon ? 96 : 32,
        h: isDragon ? 64 : 32,
        color: cfg.color,

        baseHp: hpBase,
        hp: hpBase,
        maxHp: hpBase,
        baseDamage: dmgBase,
        damage: dmgBase,
        speed: cfg.speed + (diff - 1) * 0.15,
        aggroRange: cfg.aggroRange,
        attackRange: cfg.attackRange,
        hitCooldown: cfg.hitCooldown,
        lastHitTime: 0,
        xpReward: cfg.xpReward * (0.7 + diff * 0.3),

        baseX: x,
        baseY: y,
        patrolRadius: isDragon ? 80 : 60,
        patrolAngle: Math.random() * Math.PI * 2,
        patrolTurnSpeed: 0.0015,

        isDead: false,
        deathTime: 0,
        respawnDelay: isDragon ? 0 : 10000,
        rank: 1,

        lastShotTime: 0,
        shotCooldown: cfg.hitCooldown,

        stunUntil: 0,
      };
    }

    function populateStage(stage) {
      const diff = stage.difficulty;
      const arr = stage.enemies;

      const baseCount = 4 + diff;
      function randPos() {
        return {
          x: 400 + Math.random() * (WORLD_WIDTH - 800),
          y: 400 + Math.random() * (WORLD_HEIGHT - 800),
        };
      }

      if (diff === 9) {
        const centerX = WORLD_WIDTH / 2 - 48;
        const centerY = WORLD_HEIGHT / 2 - 96;
        arr.push(createEnemy("dragon", stage.id, centerX, centerY));
        for (let i = 0; i < 4; i++) {
          const pos = randPos();
          const t = i % 2 === 0 ? "tank" : "ranged";
          arr.push(createEnemy(t, stage.id, pos.x, pos.y));
        }
      } else {
        const typesPool = ["melee", "ranged", "tank", "fast", "bomber"];
        for (let i = 0; i < baseCount; i++) {
          const t = typesPool[(i + diff) % typesPool.length];
          const pos = randPos();
          arr.push(createEnemy(t, stage.id, pos.x, pos.y));
        }
      }

      stage.initialized = true;
    }

    // ì´ˆê¸° ìŠ¤í…Œì´ì§€
    populateStage(stages[currentStageIndex]);

    // ===== ì§ì—…ë³„ ê¸°ë³¸ ê³µê²©/ìŠ¤í‚¬ êµ¬í˜„ =====
    function getDirectionVector() {
      if (player.dir === "right") return { dx: 1, dy: 0, angle: 0 };
      if (player.dir === "left")  return { dx: -1, dy: 0, angle: Math.PI };
      if (player.dir === "up")    return { dx: 0, dy: -1, angle: -Math.PI/2 };
      return { dx: 0, dy: 1, angle: Math.PI/2 }; // down
    }

    function spawnPlayerProjectile(speed, damage, color, life = 2000, size = 6) {
      const dir = getDirectionVector();
      const startX = player.x + player.w / 2;
      const startY = player.y + player.h / 2;
      playerProjectiles.push({
        x: startX,
        y: startY,
        vx: dir.dx,
        vy: dir.dy,
        speed,
        damage,
        size,
        color,
        life,
      });
    }

    // ì „ì‚¬ ê¸°ë³¸ê³µê²©: ê¸°ì¡´ ê·¼ì ‘ ë² ê¸°
    function warriorBasicAttack(now) {
      if (!player.isAttacking && now - player.lastAttackTime > player.attackCooldown) {
        player.isAttacking = true;
        player.attackTime = 0;
        player.lastAttackTime = now;
      }
    }

    // ë§ˆë²•ì‚¬ ê¸°ë³¸ê³µê²©: ë§ˆë²•íƒ„
    function mageBasicAttack(now) {
      if (now - player.lastAttackTime < player.attackCooldown) return;
      player.lastAttackTime = now;
      spawnPlayerProjectile(7, player.attackDamage, "#66ccff", 2000, 7);
    }

    // ê¶ìˆ˜ ê¸°ë³¸ê³µê²©: ë¹ ë¥¸ í™”ì‚´
    function archerBasicAttack(now) {
      if (now - player.lastAttackTime < player.attackCooldown) return;
      player.lastAttackTime = now;
      spawnPlayerProjectile(9, player.attackDamage * 0.8, "#ffee66", 1800, 5);
    }

    // ê³µìš© ì›¨ì´ë¸Œ ìŠ¤í°
    function spawnWave(range, width, damage, color) {
      const dir = getDirectionVector();
      const startX = player.x + player.w / 2;
      const startY = player.y + player.h / 2;
      skillWaves.push({
        x: startX,
        y: startY,
        dirX: dir.dx,
        dirY: dir.dy,
        speed: 8,
        length: range,
        width,
        traveled: 0,
        damage,
        color: color || "rgba(0,255,255,0.5)",
        hitSet: new Set(),
      });
    }

    // ì „ì‚¬ ìŠ¤í‚¬ X: ì§§ì§€ë§Œ ê°•í•œ ì¶©ê²©íŒŒ
    function warriorSkillX(now) {
      const t = now ?? performance.now();
      if (t - player.lastSkillXTime < player.skillXCooldown) return;
      if (player.skillGauge < player.skillXCost) return;
      player.lastSkillXTime = t;
      player.skillGauge -= player.skillXCost;

      const range = 160;
      const width = 40;
      const dmg = player.attackDamage * 1.7;
      spawnWave(range, width, dmg, "rgba(0,255,255,0.5)");
    }

    // ë§ˆë²•ì‚¬ ìŠ¤í‚¬ X: ë” ê¸¸ê³  ê°•í•œ ë§ˆë²• ì›¨ì´ë¸Œ
    function mageSkillX(now) {
      const t = now ?? performance.now();
      if (t - player.lastSkillXTime < player.skillXCooldown) return;
      if (player.skillGauge < player.skillXCost) return;
      player.lastSkillXTime = t;
      player.skillGauge -= player.skillXCost;

      const range = 220;
      const width = 50;
      const dmg = player.attackDamage * 2.0;
      spawnWave(range, width, dmg, "rgba(255,120,0,0.5)");
    }

    // ê¶ìˆ˜ ìŠ¤í‚¬ X: ê°€ëŠ˜ì§€ë§Œ ë©€ë¦¬ ë‚˜ê°€ëŠ” ê´€í†µìƒ·
    function archerSkillX(now) {
      const t = now ?? performance.now();
      if (t - player.lastSkillXTime < player.skillXCooldown) return;
      if (player.skillGauge < player.skillXCost) return;
      player.lastSkillXTime = t;
      player.skillGauge -= player.skillXCost;

      const range = 260;
      const width = 24;
      const dmg = player.attackDamage * 1.5;
      spawnWave(range, width, dmg, "rgba(200,255,0,0.5)");
    }

    // ì „ì‚¬ ìŠ¤í‚¬ C: ê¸°ë³¸ ìŠ¤í„´
    function warriorSkillC(now) {
      useStunSkill(now, 3000, 220, Math.PI / 2);
    }

    // ë§ˆë²•ì‚¬ ìŠ¤í‚¬ C: ë” ë„“ì€ ë²”ìœ„, ì•½ê°„ ê¸´ ìŠ¤í„´
    function mageSkillC(now) {
      useStunSkill(now, 3500, 260, Math.PI * 0.7);
    }

    // ê¶ìˆ˜ ìŠ¤í‚¬ C: ì§§ì€ ìŠ¤í„´ + íšŒí”¼ìš© (ìŠ¤í„´ì€ ì§§ê²Œ)
    function archerSkillC(now) {
      useStunSkill(now, 1800, 200, Math.PI / 2);
    }

    function useStunSkill(now, stunDuration, stunRange, angleWidth) {
      const t = now ?? performance.now();
      if (t - player.lastSkillCTime < player.skillCCooldown) return;
      if (player.skillGauge < player.skillCCost) return;
      player.lastSkillCTime = t;
      player.skillGauge -= player.skillCCost;

      const px = player.x + player.w / 2;
      const py = player.y + player.h / 2;
      let dirAngle = 0;
      if (player.dir === "right") dirAngle = 0;
      else if (player.dir === "up") dirAngle = -Math.PI / 2;
      else if (player.dir === "left") dirAngle = Math.PI;
      else if (player.dir === "down") dirAngle = Math.PI / 2;

      enemies.forEach((e) => {
        if (e.isDead) return;
        const cx = e.x + e.w / 2;
        const cy = e.y + e.h / 2;
        const dx = cx - px;
        const dy = cy - py;
        const dist = Math.hypot(dx, dy);
        if (dist > stunRange) return;
        const ang = Math.atan2(dy, dx);
        let diff = ang - dirAngle;
        while (diff > Math.PI) diff -= 2 * Math.PI;
        while (diff < -Math.PI) diff += 2 * Math.PI;
        if (Math.abs(diff) <= angleWidth / 2) {
          e.stunUntil = performance.now() + stunDuration;
        }
      });
    }

    // ===== ë©”ì¸ ë£¨í”„ =====
    let lastTime = performance.now();

    function update(dt) {
      const now = performance.now();

      if (!selectedJob) {
        // ì§ì—… ì„ íƒ ì „ì—ëŠ” ê²Œì„ ë¡œì§ ì •ì§€
        return;
      }

      // ë°©ì–´ ìŠ¤í‚¬(S)
      const wantGuard = isPressed("s");
      if (wantGuard && player.skillGauge > 0) {
        player.isGuarding = true;
      } else {
        player.isGuarding = false;
      }
      if (player.isGuarding) {
        const drain = (player.guardDrainPerSec * dt) / 1000;
        player.skillGauge = clamp(player.skillGauge - drain, 0, player.skillGaugeMax);
        if (player.skillGauge <= 0) player.isGuarding = false;
      }

      // ì´ë™
      let dx = 0;
      let dy = 0;
      if (isPressed("ArrowLeft"))  { dx -= 1; player.dir = "left"; }
      if (isPressed("ArrowRight")) { dx += 1; player.dir = "right"; }
      if (isPressed("ArrowUp"))    { dy -= 1; player.dir = "up"; }
      if (isPressed("ArrowDown"))  { dy += 1; player.dir = "down"; }

      if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy);
        dx /= len;
        dy /= len;
        const moveSpeed = player.isGuarding ? player.speed * 0.5 : player.speed;
        player.x += dx * moveSpeed;
        player.y += dy * moveSpeed;
      }

      player.x = clamp(player.x, 0, WORLD_WIDTH - player.w);
      player.y = clamp(player.y, 0, WORLD_HEIGHT - player.h);

      // ê¸°ë³¸ ê³µê²© (A)
      if (isPressed("a") && player.performBasicAttack) {
        player.performBasicAttack(now);
      }

      // ì „ì‚¬ ê·¼ì ‘ ê³µê²© íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
      if (selectedJob === "warrior") {
        if (player.isAttacking) {
          player.attackTime += dt;
          if (player.attackTime >= player.attackDuration) {
            player.isAttacking = false;
          }
        }
      } else {
        player.isAttacking = false;
      }

      // ìŠ¤í‚¬ ì…ë ¥
      if (isPressed("x") && player.performSkillX) {
        player.performSkillX(now);
      }
      if (isPressed("c") && player.performSkillC) {
        player.performSkillC(now);
      }

      // ê¸°ë³¸ ê³µê²© ë²”ìœ„(ì „ì‚¬ë§Œ)
      let attackBox = null;
      if (selectedJob === "warrior" && player.isAttacking) {
        const range = 28;
        const thickness = 24;
        if (player.dir === "right") {
          attackBox = {
            x: player.x + player.w,
            y: player.y + (player.h - thickness) / 2,
            w: range,
            h: thickness,
          };
        } else if (player.dir === "left") {
          attackBox = {
            x: player.x - range,
            y: player.y + (player.h - thickness) / 2,
            w: range,
            h: thickness,
          };
        } else if (player.dir === "up") {
          attackBox = {
            x: player.x + (player.w - thickness) / 2,
            y: player.y - range,
            w: thickness,
            h: range,
          };
        } else if (player.dir === "down") {
          attackBox = {
            x: player.x + (player.w - thickness) / 2,
            y: player.y + player.h,
            w: thickness,
            h: range,
          };
        }
      }

      // ëª¬ìŠ¤í„° ì—…ë°ì´íŠ¸
      enemies.forEach((e) => {
        const isDragon = e.type === "dragon";

        if (e.isDead) {
          if (!isDragon && e.respawnDelay > 0) {
            if (now - e.deathTime >= e.respawnDelay) {
              e.rank += 1;
              e.maxHp = e.baseHp * (1 + (e.rank - 1) * 0.4);
              e.hp = e.maxHp;
              e.damage = e.baseDamage * (1 + (e.rank - 1) * 0.3);
              e.x = e.baseX;
              e.y = e.baseY;
              e.isDead = false;
              e.stunUntil = 0;
            }
          }
          return;
        }

        const stunned = now < e.stunUntil;
        const cx = e.x + e.w / 2;
        const cy = e.y + e.h / 2;
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        const dist = Math.hypot(px - cx, py - cy) || 1;
        const toPlayerX = (px - cx) / dist;
        const toPlayerY = (py - cy) / dist;

        let moveX = 0;
        let moveY = 0;

        if (!stunned) {
          if (dist < e.aggroRange) {
            if (["melee","tank","fast","bomber"].includes(e.type)) {
              if (dist > e.attackRange * 0.9) {
                moveX = toPlayerX * e.speed;
                moveY = toPlayerY * e.speed;
              }
              if (dist <= e.attackRange) {
                if (now - e.lastHitTime > e.hitCooldown) {
                  let dmg = e.damage;
                  if (e.type === "bomber") dmg *= 1.2;
                  damagePlayer(dmg);
                  e.lastHitTime = now;
                }
              }
            } else if (e.type === "ranged" || e.type === "dragon") {
              const desiredMin = e.attackRange * 0.5;
              const desiredMax = e.attackRange * 0.9;
              if (dist > desiredMax) {
                moveX = toPlayerX * e.speed;
                moveY = toPlayerY * e.speed;
              } else if (dist < desiredMin) {
                moveX = -toPlayerX * e.speed;
                moveY = -toPlayerY * e.speed;
              }
              if (dist <= e.attackRange && now - e.lastShotTime > e.shotCooldown) {
                if (e.type === "dragon") {
                  spawnProjectile(e, toPlayerX, toPlayerY, 1.3);
                  const ang = Math.atan2(toPlayerY, toPlayerX);
                  spawnProjectile(e, Math.cos(ang + 0.2), Math.sin(ang + 0.2), 1.3);
                  spawnProjectile(e, Math.cos(ang - 0.2), Math.sin(ang - 0.2), 1.3);
                } else {
                  spawnProjectile(e, toPlayerX, toPlayerY, 1.0);
                }
                e.lastShotTime = now;
              }
            }
          } else {
            e.patrolAngle += e.patrolTurnSpeed * dt;
            const targetX = e.baseX + Math.cos(e.patrolAngle) * e.patrolRadius;
            const targetY = e.baseY + Math.sin(e.patrolAngle) * e.patrolRadius;
            const dxP = targetX - e.x;
            const dyP = targetY - e.y;
            const dP = Math.hypot(dxP, dyP) || 1;
            moveX = (dxP / dP) * 0.6;
            moveY = (dyP / dP) * 0.6;
          }
        }

        e.x += moveX;
        e.y += moveY;
        e.x = clamp(e.x, 0, WORLD_WIDTH - e.w);
        e.y = clamp(e.y, 0, WORLD_HEIGHT - e.h);

        // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ ì‹œ ê´€í†µ ë°©ì§€ (ëª¬ìŠ¤í„°ë¥¼ ë°€ì–´ëƒ„)
        const pRect = { x: player.x, y: player.y, w: player.w, h: player.h };
        const eRect = { x: e.x, y: e.y, w: e.w, h: e.h };
        if (rectsOverlap(eRect, pRect)) {
          const px2 = player.x + player.w / 2;
          const py2 = player.y + player.h / 2;
          const ex2 = e.x + e.w / 2;
          const ey2 = e.y + e.h / 2;
          let dx2 = ex2 - px2;
          let dy2 = ey2 - py2;
          let dist2 = Math.hypot(dx2, dy2) || 1;
          const minDist = (Math.max(player.w, player.h) + Math.max(e.w, e.h)) / 2;
          const overlap = minDist - dist2;
          if (overlap > 0) {
            dx2 /= dist2;
            dy2 /= dist2;
            e.x += dx2 * overlap;
            e.y += dy2 * overlap;
            e.x = clamp(e.x, 0, WORLD_WIDTH - e.w);
            e.y = clamp(e.y, 0, WORLD_HEIGHT - e.h);
          }
        }

        // ì „ì‚¬ ê·¼ì ‘ ê³µê²© í”¼ê²©
        if (attackBox && !e.isDead) {
          const enemyRect = { x: e.x, y: e.y, w: e.w, h: e.h };
          if (rectsOverlap(attackBox, enemyRect)) {
            let dmg = player.attackDamage * (dt / player.attackDuration);
            if (e.type === "dragon" && player.level < 15) {
              dmg *= 0.2;
            }
            e.hp -= dmg;
            addSkillGauge(player.skillGaugeOnHit * (dt / player.attackDuration));
            if (e.hp <= 0) {
              handleEnemyDeath(e);
            }
          }
        }
      });

      // ìŠ¤í‚¬ ì›¨ì´ë¸Œ ì—…ë°ì´íŠ¸
      for (let i = skillWaves.length - 1; i >= 0; i--) {
        const wv = skillWaves[i];
        const step = wv.speed * (dt / 16);
        wv.x += wv.dirX * step;
        wv.y += wv.dirY * step;
        wv.traveled += step;
        if (wv.traveled >= wv.length) {
          skillWaves.splice(i, 1);
          continue;
        }
        const halfW = wv.width / 2;
        const rect = {
          x: wv.x - halfW,
          y: wv.y - halfW,
          w: wv.width,
          h: wv.width,
        };
        enemies.forEach((e) => {
          if (e.isDead) return;
          const key = e.type + "_" + e.baseX + "_" + e.baseY + "_" + e.rank;
          if (wv.hitSet.has(key)) return;
          const enemyRect = { x: e.x, y: e.y, w: e.w, h: e.h };
          if (rectsOverlap(rect, enemyRect)) {
            let dmg = wv.damage;
            if (e.type === "dragon" && player.level < 15) {
              dmg *= 0.3;
            }
            e.hp -= dmg;
            addSkillGauge(player.skillGaugeOnHit * 2);
            if (e.hp <= 0) {
              handleEnemyDeath(e);
            }
            wv.hitSet.add(key);
          }
        });
      }

      // ì  íˆ¬ì‚¬ì²´
      for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
        const p = enemyProjectiles[i];
        p.x += p.vx * p.speed;
        p.y += p.vy * p.speed;
        p.life -= dt;

        const projRect = { x: p.x, y: p.y, w: p.size, h: p.size };
        const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
        if (rectsOverlap(projRect, playerRect)) {
          damagePlayer(p.damage);
          enemyProjectiles.splice(i, 1);
          continue;
        }

        if (
          p.life <= 0 ||
          p.x < 0 || p.x > WORLD_WIDTH ||
          p.y < 0 || p.y > WORLD_HEIGHT
        ) {
          enemyProjectiles.splice(i, 1);
        }
      }

      // í”Œë ˆì´ì–´ íˆ¬ì‚¬ì²´
      for (let i = playerProjectiles.length - 1; i >= 0; i--) {
        const p = playerProjectiles[i];
        p.x += p.vx * p.speed;
        p.y += p.vy * p.speed;
        p.life -= dt;

        const projRect = { x: p.x, y: p.y, w: p.size, h: p.size };

        enemies.forEach((e) => {
          if (e.isDead) return;
          const enemyRect = { x: e.x, y: e.y, w: e.w, h: e.h };
          if (rectsOverlap(projRect, enemyRect)) {
            let dmg = p.damage;
            if (e.type === "dragon" && player.level < 15) {
              dmg *= 0.3;
            }
            e.hp -= dmg;
            addSkillGauge(player.skillGaugeOnHit);
            if (e.hp <= 0) {
              handleEnemyDeath(e);
            }
            p.life = 0;
          }
        });

        if (
          p.life <= 0 ||
          p.x < 0 || p.x > WORLD_WIDTH ||
          p.y < 0 || p.y > WORLD_HEIGHT
        ) {
          playerProjectiles.splice(i, 1);
        }
      }

      // ì•„ì´í…œ íšë“
      for (let i = items.length - 1; i >= 0; i--) {
        const it = items[i];
        const itemRect = { x: it.x, y: it.y, w: it.w, h: it.h };
        const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
        if (rectsOverlap(itemRect, playerRect)) {
          ITEM_TYPES[it.type].apply();
          items.splice(i, 1);
        }
      }

      // í¬íƒˆ
      handlePortals();

      // ì¹´ë©”ë¼
      camera.x = clamp(
        player.x + player.w / 2 - camera.w / 2,
        0,
        WORLD_WIDTH - camera.w
      );
      camera.y = clamp(
        player.y + player.h / 2 - camera.h / 2,
        0,
        WORLD_HEIGHT - camera.h
      );
    }

    function handleEnemyDeath(e) {
      if (e.isDead) return;
      e.hp = 0;
      e.isDead = true;
      e.deathTime = performance.now();
      player.kills += 1;
      gainXP(e.xpReward);
      addSkillGauge(player.skillGaugeOnKill);

      if (Math.random() < 0.4) {
        const keys = Object.keys(ITEM_TYPES);
        const type = keys[Math.floor(Math.random() * keys.length)];
        items.push({
          type,
          x: e.x + e.w / 2 - 10,
          y: e.y + e.h / 2 - 10,
          w: 20,
          h: 20,
        });
      }
    }

    function spawnProjectile(enemy, dirX, dirY, speedMul) {
      const norm = Math.hypot(dirX, dirY) || 1;
      const vx = dirX / norm;
      const vy = dirY / norm;

      enemyProjectiles.push({
        x: enemy.x + enemy.w / 2,
        y: enemy.y + enemy.h / 2,
        vx,
        vy,
        speed: 4 * (speedMul || 1),
        size: enemy.type === "dragon" ? 14 : 8,
        damage: enemy.type === "dragon" ? enemy.damage * 0.6 : enemy.damage * 0.5,
        life: 2500,
      });
    }

    // ===== í¬íƒˆ =====
    function handlePortals() {
      const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
      const portals = getCurrentStagePortals();
      for (const p of portals) {
        if (p.targetStage === null) continue;
        if (rectsOverlap(playerRect, p.rect)) {
          goToStage(p.targetStage, p.dirFrom);
          break;
        }
      }
    }

    function getCurrentStagePortals() {
      const list = [];
      const idx = currentStageIndex;
      const portalWidth = 80;
      const portalThickness = 40;

      list.push({
        dirFrom: "north",
        targetStage: getNeighborStage(idx, "north"),
        rect: {
          x: WORLD_WIDTH / 2 - portalWidth / 2,
          y: 0,
          w: portalWidth,
          h: portalThickness,
        },
      });
      list.push({
        dirFrom: "south",
        targetStage: getNeighborStage(idx, "south"),
        rect: {
          x: WORLD_WIDTH / 2 - portalWidth / 2,
          y: WORLD_HEIGHT - portalThickness,
          w: portalWidth,
          h: portalThickness,
        },
      });
      list.push({
        dirFrom: "west",
        targetStage: getNeighborStage(idx, "west"),
        rect: {
          x: 0,
          y: WORLD_HEIGHT / 2 - portalWidth / 2,
          w: portalThickness,
          h: portalWidth,
        },
      });
      list.push({
        dirFrom: "east",
        targetStage: getNeighborStage(idx, "east"),
        rect: {
          x: WORLD_WIDTH - portalThickness,
          y: WORLD_HEIGHT / 2 - portalWidth / 2,
          w: portalThickness,
          h: portalWidth,
        },
      });

      return list;
    }

    // ===== ë Œë”ë§ =====
    function draw() {
      const offsetX = camera.x;
      const offsetY = camera.y;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ë°”ë‹¥ ê²©ì
      ctx.fillStyle = "#303030";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "#3a3a3a";
      ctx.lineWidth = 1;
      const tileSize = 40;
      const startX = Math.floor(offsetX / tileSize) * tileSize;
      const endX = offsetX + canvas.width;
      const startY = Math.floor(offsetY / tileSize) * tileSize;
      const endY = offsetY + canvas.height;

      for (let x = startX; x <= endX; x += tileSize) {
        ctx.beginPath();
        ctx.moveTo(x - offsetX, 0);
        ctx.lineTo(x - offsetX, canvas.height);
        ctx.stroke();
      }
      for (let y = startY; y <= endY; y += tileSize) {
        ctx.beginPath();
        ctx.moveTo(0, y - offsetY);
        ctx.lineTo(canvas.width, y - offsetY);
        ctx.stroke();
      }

      // í¬íƒˆ
      const portals = getCurrentStagePortals();
      portals.forEach((p) => {
        if (p.targetStage === null) return;
        const sx = p.rect.x - offsetX;
        const sy = p.rect.y - offsetY;
        ctx.fillStyle = "rgba(0, 200, 255, 0.4)";
        ctx.fillRect(sx, sy, p.rect.w, p.rect.h);
        ctx.strokeStyle = "rgba(0, 255, 255, 0.9)";
        ctx.lineWidth = 2;
        ctx.strokeRect(sx, sy, p.rect.w, p.rect.h);
      });

      // ì•„ì´í…œ
      items.forEach((it) => {
        const def = ITEM_TYPES[it.type];
        const sx = it.x - offsetX;
        const sy = it.y - offsetY;
        ctx.fillStyle = def.color;
        ctx.fillRect(sx, sy, it.w, it.h);
        ctx.fillStyle = "#000";
        ctx.font = "10px system-ui";
        ctx.textAlign = "center";
        ctx.fillText(def.label, sx + it.w / 2, sy + it.h + 10);
        ctx.textAlign = "left";
      });

      // ëª¬ìŠ¤í„°
      enemies.forEach((e) => {
        if (e.isDead) return;
        const sx = e.x - offsetX;
        const sy = e.y - offsetY;
        const stunned = performance.now() < e.stunUntil;

        ctx.fillStyle = e.color;
        ctx.fillRect(sx, sy, e.w, e.h);

        if (stunned) {
          ctx.strokeStyle = "#ffff00";
          ctx.lineWidth = 2;
          ctx.strokeRect(sx, sy, e.w, e.h);
        }

        const barWidth = e.w;
        const barHeight = 4;
        const hpRatio = e.hp / e.maxHp;
        ctx.fillStyle = "#550000";
        ctx.fillRect(sx, sy - barHeight - 2, barWidth, barHeight);
        ctx.fillStyle = "#ff5252";
        ctx.fillRect(sx, sy - barHeight - 2, barWidth * hpRatio, barHeight);

        ctx.fillStyle = "#fff";
        ctx.font = "10px system-ui";
        ctx.textAlign = "center";
        ctx.fillText(e.type === "dragon" ? "DRAGON" : e.type.toUpperCase(), sx + e.w / 2, sy - barHeight - 6);
        ctx.textAlign = "left";
      });

      // ì  íˆ¬ì‚¬ì²´
      enemyProjectiles.forEach((p) => {
        const sx = p.x - offsetX;
        const sy = p.y - offsetY;
        ctx.fillStyle = p.size > 10 ? "#ff9800" : "#ffeb3b";
        ctx.fillRect(sx, sy, p.size, p.size);
      });

      // í”Œë ˆì´ì–´ íˆ¬ì‚¬ì²´
      playerProjectiles.forEach((p) => {
        const sx = p.x - offsetX;
        const sy = p.y - offsetY;
        ctx.fillStyle = p.color || "#ffffff";
        ctx.fillRect(sx, sy, p.size, p.size);
      });

      // ìŠ¤í‚¬ ì›¨ì´ë¸Œ
      skillWaves.forEach((wv) => {
        const sx = wv.x - offsetX;
        const sy = wv.y - offsetY;
        ctx.fillStyle = wv.color || "rgba(0,255,255,0.5)";
        ctx.beginPath();
        ctx.arc(sx, sy, wv.width / 2, 0, Math.PI * 2);
        ctx.fill();
      });

      // í”Œë ˆì´ì–´
      const px = player.x - offsetX;
      const py = player.y - offsetY;

      ctx.fillStyle = player.isGuarding ? "#90caf9" : player.color;
      ctx.fillRect(px, py, player.w, player.h);

      // ëˆˆ
      ctx.fillStyle = "#000";
      const eyeSize = 4;
      if (player.dir === "right") {
        ctx.fillRect(px + player.w - 6, py + 8, eyeSize, eyeSize);
      } else if (player.dir === "left") {
        ctx.fillRect(px + 2, py + 8, eyeSize, eyeSize);
      } else if (player.dir === "up") {
        ctx.fillRect(px + 7, py + 4, eyeSize, eyeSize);
      } else if (player.dir === "down") {
        ctx.fillRect(px + 7, py + player.h - 8, eyeSize, eyeSize);
      }

      // ì „ì‚¬ ê³µê²© ë²”ìœ„ í‘œì‹œ
      if (selectedJob === "warrior" && player.isAttacking) {
        const range = 28;
        const thickness = 24;
        let ax, ay, aw, ah;
        if (player.dir === "right") {
          ax = player.x + player.w - offsetX;
          ay = player.y + (player.h - thickness) / 2 - offsetY;
          aw = range;
          ah = thickness;
        } else if (player.dir === "left") {
          ax = player.x - range - offsetX;
          ay = player.y + (player.h - thickness) / 2 - offsetY;
          aw = range;
          ah = thickness;
        } else if (player.dir === "up") {
          ax = player.x + (player.w - thickness) / 2 - offsetX;
          ay = player.y - range - offsetY;
          aw = thickness;
          ah = range;
        } else {
          ax = player.x + (player.w - thickness) / 2 - offsetX;
          ay = player.y + player.h - offsetY;
          aw = thickness;
          ah = range;
        }
        ctx.fillStyle = "rgba(255,255,0,0.3)";
        ctx.fillRect(ax, ay, aw, ah);
      }

      // UI
      ctx.textAlign = "left";
      ctx.fillStyle = "#fff";
      ctx.font = "16px system-ui";
      ctx.fillText("HP:", 16, 24);

      const hpBarX = 60;
      const hpBarY = 10;
      const hpBarW = 220;
      const hpBarH = 14;
      const hpRatio = player.hp / player.maxHp;

      ctx.fillStyle = "#555";
      ctx.fillRect(hpBarX, hpBarY, hpBarW, hpBarH);
      ctx.fillStyle = "#4caf50";
      ctx.fillRect(hpBarX, hpBarY, hpBarW * hpRatio, hpBarH);
      ctx.strokeStyle = "#222";
      ctx.strokeRect(hpBarX, hpBarY, hpBarW, hpBarH);

      ctx.fillStyle = "#fff";
      ctx.font = "13px system-ui";
      ctx.fillText(
        `${Math.round(player.hp)}/${player.maxHp}`,
        hpBarX + 5,
        hpBarY + 11
      );

      const panelY = 38;
      ctx.font = "14px system-ui";
      ctx.fillText(
        `ì§ì—…: ${selectedJob ? selectedJob.toUpperCase() : "NONE"}  Lv.${player.level}  XP: ${Math.floor(player.xp)}/${player.xpToNext}`,
        16,
        panelY
      );
      ctx.fillText(`Kills: ${player.kills}`, 16, panelY + 18);

      const stage = stages[currentStageIndex];
      ctx.fillText(
        `Stage ${stage.difficulty} / 9`,
        16,
        panelY + 36
      );

      // ìŠ¤í‚¬ ê²Œì´ì§€
      const sgX = 16;
      const sgY = panelY + 52;
      const sgW = 260;
      const sgH = 12;
      const sgRatio = player.skillGauge / player.skillGaugeMax;

      ctx.fillText("Skill Gauge", sgX, sgY - 4);
      ctx.fillStyle = "#555";
      ctx.fillRect(sgX, sgY, sgW, sgH);
      ctx.fillStyle = "#00bcd4";
      ctx.fillRect(sgX, sgY, sgW * sgRatio, sgH);
      ctx.strokeStyle = "#222";
      ctx.strokeRect(sgX, sgY, sgW, sgH);

      ctx.font = "12px system-ui";
      const canX = player.skillGauge >= player.skillXCost ? "READY" : "â€¦";
      const canC = player.skillGauge >= player.skillCCost ? "READY" : "â€¦";
      ctx.fillStyle = canX === "READY" ? "#00e676" : "#ccc";
      ctx.fillText(`X: Skill1 (${player.skillXCost}) ${canX}`, sgX, sgY + 24);
      ctx.fillStyle = canC === "READY" ? "#00e676" : "#ccc";
      ctx.fillText(`C: Skill2 (${player.skillCCost}) ${canC}`, sgX, sgY + 40);

      ctx.fillStyle = player.isGuarding ? "#00e676" : "#ccc";
      ctx.fillText(`S: Guard (HOLD, ê²Œì´ì§€ ì§€ì† ì†Œëª¨)`, sgX, sgY + 56);

      if (player.hp <= 0) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ff5252";
        ctx.textAlign = "center";
        ctx.font = "28px system-ui";
        ctx.fillText("ê²Œì„ ì˜¤ë²„! F5ë¡œ ë‹¤ì‹œ ì‹œì‘", canvas.width / 2, canvas.height / 2);
        ctx.textAlign = "left";
      }
    }

    function gameLoop(timestamp) {
      const dt = timestamp - lastTime;
      lastTime = timestamp;

      if (player.hp > 0) {
        update(dt);
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>

